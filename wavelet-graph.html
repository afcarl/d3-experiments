<!DOCTYPE html>
<html>
  <head>
    <title>Wavelet Dilation Graph</title>
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <!--<script src="/js/d3.min.js"></script>-->
  </head>
  <body>
    <style>

    .link {
      fill: none;
      stroke-width: 1.5px;
      stroke-opacity: 0.3;
    }

    .link-highlight {
      fill: none;
      stroke-width: 3px;
      stroke-opacity: 1;
    }

    .node {
      fill: lightSlateGray;
      stroke: none;
    }

    .node-hover {
      fill: black;
    }

    </style>

    <script>

    function node_id(n) {
      return "n" + n.level + n.position * Math.pow(2, n.level)
    }

    function create_data(max_level, num_coefficients, new_position) {
      var first_node = {"level": 0, "position": 0}
      var nodes = {"n00": first_node};
      var links = []

      for (var l = 1; l <= max_level; l++) {
        var current_nodes = d3.values(nodes).filter(function(d) {return d.level == l-1});
        current_nodes.forEach(function(node) {
          var target_id = node_id(node);
          for (var c = 0; c < num_coefficients; c++) {
            p = new_position(node, c);
            var new_node = {"level": l, "position": p};
            var new_id = node_id(new_node);
            nodes[new_id] = new_node
            links.push({"source": new_id, "target": target_id, "value": c});
          }
        });
      }

      return [nodes, links]
    }

    var max_level = 4;
    var num_coeff = 4;

    function filterbank_connection(node, c) {
      var new_position = node.position + c / Math.pow(2, node.level+1);
      return new_position
    }
    function dilation_connection(node, c) {
      var new_position = (node.position + c) / 2;
      return new_position
    }

    function find_paths(source, target, path=[], links_data) {
      // find all links from the source
      next_links = links_data.filter(function(d) { return d.source == source });
      if(path.length == 0) {
        paths_to_target = [];
      }

      next_links.forEach(function(this_link) {
        new_path = path.slice(0);
        new_path.push(this_link);
        if(this_link.target == target) {
          paths_to_target.push(new_path);
        } else {
          find_paths(this_link.target, target, new_path, links_data);
        }
      });

      return paths_to_target
    }

    function link(d) {
      return "M" + d.source.x + "," + d.source.y
          + "C" + d.source.x + "," + (d.source.y + d.target.y) / 2
          + " " + d.target.x + "," + (d.source.y + d.target.y) / 2
          + " " + d.target.x + "," + d.target.y;
    }

    // setup scales and layout
    var svg = d3.select("#filterbank");

    [nodes_data, links_data_1] = create_data(max_level, num_coeff, filterbank_connection);
    [nodes_data_2, links_data_2] = create_data(max_level, num_coeff, dilation_connection);
    var data = [[nodes_data, links_data_1], [nodes_data_2, links_data_2]];

    function node_position(n) {
      p = {"x": x(n.position), "y": y(n.level)};
      return p
    }

    var margin = {top: 20, right: 20, bottom: 20, left: 20},
        width = 540,
        height = 200;

    var color = d3.scaleOrdinal(d3.schemeCategory10),
        x = d3.scaleLinear()
              .range([width, margin.left])
              .domain([0, d3.max(d3.values(nodes_data), function(d) { return d.position; })]);
        y = d3.scaleLinear()
              .range([height, margin.top])
              .domain([0, d3.max(d3.values(nodes_data), function(d) { return d.level; })]);

    var svg = d3.select("body").selectAll("svg")
        .data(data)
      .enter().append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

    //create links
    var links = svg.selectAll(".link")
      .data(function(d) { return d[1] })
      .enter().append("path")
        .attr("class", "link")
        .attr("id", function(d) { return d.source +  d.target })
        .attr("stroke", function(d) { return color(d.value) })
        .attr("d", function(d) {
          return link({
            "source": node_position(nodes_data[d.source]),
            "target": node_position(nodes_data[d.target])
          })
        });

    // create nodes
    var node = svg.selectAll(".node")
      .data(function(d) { return d3.values(d[0]) })
      .enter().append("g")
        .attr("class", "node")
        .attr("id", function(d) { return node_id(d) })
        .attr("transform", function(d) {
          p = node_position(d)
          return "translate(" + p.x + "," + p.y + ")";
        });

    node.append("circle")
        .attr("r", 6)
        .on("mouseover", function(d, i) {
          id = node_id(d);
          n = d3.selectAll("#" + id);
          n.each(function(d) {connect_node(this, id);})
          //connect_node(n, id);
        })
        .on("mouseout", function(d, i) {
          d3.selectAll(".node-hover")
              .attr("class", "node");
          d3.selectAll(".link-highlight")
              .attr("class", "link");
          d3.selectAll(".color_path").remove();
        });

    svg.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + (height + 20) + ")")
        .call(d3.axisBottom(x));

    var color_size = 15;
    var color_margin_x = 8;
    var color_margin_y = 1;

    function connect_node(node, node_id) {
      d3.select(node)
          .attr("class", "node-hover");
      var this_svg = d3.select(node.parentNode);
      paths = find_paths(node_id, "n00", [], this_svg.datum()[1]);

      draw_colors(paths.reverse());
      paths = [].concat.apply([], paths);
      path_ids = paths.reduce(function(t, c) {return t + ", #" + c.source + c.target}, "#foo");
      var selected_paths = this_svg.selectAll(path_ids)
                                      .attr("class", "link-highlight");
    }

    function draw_colors(paths) {
      var color_paths = svg.selectAll(".color_path")
        .data(paths)
        .enter().append("g")
          .attr("class", "color_path")
          .attr("transform", function (d, i) {
            return "translate(" + (margin.left + i * (color_size + color_margin_x)) + "," + (height) + ")"
          })
        .selectAll("rect")
        .data(function(d) { return d.reverse()})
        .enter().append("rect")
          .attr("width", color_size)
          .attr("height", color_size)
          .attr("y", function(d, i) { return -(color_size + color_margin_y) * i})
          .attr("fill", function(d) { return color(d.value) });
    }


    </script>
  </body>
</html>
